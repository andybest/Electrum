/*
 MIT License

 Copyright (c) 2018 Andy Best

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


#ifndef ELECTRUM_ANALYZER_H
#define ELECTRUM_ANALYZER_H

#include "types/Types.h"
#include "EvaluationPhase.h"
#include "Namespace.h"
#include <memory>
#include <boost/variant.hpp>
#include <string>
#include <unordered_map>

namespace electrum {

using std::shared_ptr;
using std::make_shared;
using std::string;
using std::unordered_map;

enum AnalyzerNodeType {
  kAnalyzerNodeTypeIf,
  kAnalyzerNodeTypeConstant,
  kAnalyzerNodeTypeDo,
  kAnalyzerNodeTypeLambda,
  kAnalyzerNodeTypeDefMacro,
  kAnalyzerNodeTypeDef,
  kAnalyzerNodeTypeVarLookup,
  kAnalyzerNodeTypeMaybeInvoke,
  kAnalyzerNodeTypeMacroExpand,
  kAnalyzerNodeTypeDefFFIFunction,
  kAnalyzerNodeTypeConstantList,
  kAnalyzerNodeTypeEvalWhen,
  kAnalyzerNodeTypeTry,
  kAnalyzerNodeTypeCatch,
  kAnalyzerNodeTypeThrow
};

class AnalyzerNode {
public:
    virtual ~AnalyzerNode() = default;

    /// A reference to the original source position of the form
    shared_ptr<SourcePosition> sourcePosition;

    /// The closed overs generated by the `collectClosedOvers` pass
    vector<string> closed_overs;

    /// A flag indicating whether the closed overs have already been collected
    bool collected_closed_overs;

    /// The depth of this node from the top level
    int64_t node_depth = -1;

    /// The phases in which the node will be evaluated
    EvaluationPhase evaluation_phase = kEvaluationPhaseNone;

    /// The node's children
    virtual vector<shared_ptr<AnalyzerNode>> children() { return {}; };

    /// The type of the node
    virtual AnalyzerNodeType nodeType() = 0;
};

/**
 * Node that represents an 'if' expression.
 * Condition should be a bool
 * If alternative is nil, that branch should return nil.
 */
class IfAnalyzerNode : public AnalyzerNode {
public:
    shared_ptr<AnalyzerNode> condition;
    shared_ptr<AnalyzerNode> consequent;
    shared_ptr<AnalyzerNode> alternative;

    vector<shared_ptr<AnalyzerNode>> children() override {
        return {condition, consequent, alternative};
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeIf;
    }
};

/**
 * The type of constant that the constant node represents.
 */
enum AnalyzerConstantType {
  kAnalyzerConstantTypeInteger,
  kAnalyzerConstantTypeFloat,
  kAnalyzerConstantTypeBoolean,
  kAnalyzerConstantTypeString,
  kAnalyzerConstantTypeSymbol,
  kAnalyzerConstantTypeKeyword,
  kAnalyzerConstantTypeNil
};

/*
 * Node that represents a constant value.
 */
class ConstantValueAnalyzerNode : public AnalyzerNode {
public:
    /// Type of the constant
    AnalyzerConstantType type;

    /// Value of the constant
    boost::variant<int64_t,
                   double,
                   bool,
                   shared_ptr<string>> value;

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeConstant;
    }
};

/*
 * Node that represents a list
 */
class ConstantListAnalyzerNode : public AnalyzerNode {
public:
    /// The values in the list
    vector<shared_ptr<AnalyzerNode>> values;

    vector<shared_ptr<AnalyzerNode>> children() override {
        return values;
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeConstantList;
    }
};

/*
 * Node that represents a 'do' form
 */
class DoAnalyzerNode : public AnalyzerNode {
public:
    /// A vector of all statements in the do form, except the return value
    vector<shared_ptr<AnalyzerNode>> statements;
    /// The last value in the do form
    shared_ptr<AnalyzerNode> returnValue;

    vector<shared_ptr<AnalyzerNode>> children() override {
        auto rv = vector<shared_ptr<AnalyzerNode>>(statements);
        rv.push_back(returnValue);
        return rv;
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeDo;
    }
};

class LambdaAnalyzerNode : public AnalyzerNode {
public:
    /// A vector of the argument names
    vector<shared_ptr<AnalyzerNode>> arg_name_nodes;

    vector<shared_ptr<std::string>> arg_names;

    /// Whether the func has a rest arg
    bool has_rest_arg;

    /// The name of the rest arg
    shared_ptr<std::string> rest_arg_name;

    /// A do node representing the body
    shared_ptr<AnalyzerNode> body;

    vector<shared_ptr<AnalyzerNode>> children() override {
        return body->children();
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeLambda;
    }
};

class DefMacroAnalyzerNode : public AnalyzerNode {
public:
    /// The binding name
    shared_ptr<std::string> name;

    /// A vector of the argument names
    vector<shared_ptr<AnalyzerNode>> arg_name_nodes;
    vector<shared_ptr<std::string>> arg_names;

    /// A do node representing the body
    shared_ptr<AnalyzerNode> body;

    vector<shared_ptr<AnalyzerNode>> children() override {
        return body->children();
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeDefMacro;
    }
};

class DefAnalyzerNode : public AnalyzerNode {
public:
    /// The binding name
    shared_ptr<std::string> name;

    /// The binding value
    shared_ptr<AnalyzerNode> value;

    vector<shared_ptr<AnalyzerNode>> children() override {
        return {value};
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeDef;
    }
};

class VarLookupNode : public AnalyzerNode {
public:
    /// The binding name
    shared_ptr<std::string> name;

    /// Is it a global variable?
    bool is_global;

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeVarLookup;
    }
};

class MacroExpandAnalyzerNode : public AnalyzerNode {
public:
    /// Expander to call
    shared_ptr<AnalyzerNode> macro;

    /// Macro arguments
    std::vector<shared_ptr<AnalyzerNode>> args;

    /// Specifies whether the result be evaluated after expansion
    bool do_evaluate;

    vector<shared_ptr<AnalyzerNode>> children() override {
        vector<shared_ptr<AnalyzerNode>> c = {macro};

        for (auto a: args) {
            c.push_back(a);
        }

        return c;
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeMacroExpand;
    }
};

class MaybeInvokeAnalyzerNode : public AnalyzerNode {
public:
    /// Function to call
    shared_ptr<AnalyzerNode> fn;

    /// Function call arguments
    std::vector<shared_ptr<AnalyzerNode>> args;

    vector<shared_ptr<AnalyzerNode>> children() override {
        vector<shared_ptr<AnalyzerNode>> c = {fn};

        for (auto a: args) {
            c.push_back(a);
        }

        return c;
    }

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeMaybeInvoke;
    }
};

enum FFIType : int64_t {
  kFFITypeUnknown = -1,
  kFFITypeElectrumValue
};

static FFIType ffi_type_from_keyword(string input) {
    if (input=="el") {
        return kFFITypeElectrumValue;
    }

    return kFFITypeUnknown;
}

class DefFFIFunctionNode : public AnalyzerNode {
public:
    /// Binding name
    shared_ptr<string> binding;

    /// Function name
    shared_ptr<string> func_name;

    /// Return type
    FFIType return_type;

    vector<FFIType> arg_types;

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeDefFFIFunction;
    }
};

class EvalWhenAnalyzerNode : public AnalyzerNode {
public:
    /// Which evaluation phases the body will be evaluated in
    EvaluationPhase phases;

    /// All but the last body form
    vector<shared_ptr<AnalyzerNode>> body;

    /// The last body form (returned value)
    shared_ptr<AnalyzerNode> last;

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeEvalWhen;
    }

    vector<shared_ptr<AnalyzerNode>> children() override {
        vector<shared_ptr<AnalyzerNode>> c;

        for (const auto& b: body) {
            c.push_back(b);
        }

        c.push_back(last);

        return c;
    }
};

class CatchAnalyzerNode : public AnalyzerNode {
public:
    shared_ptr<string> exception_type;

    shared_ptr<string> exception_binding;

    vector<shared_ptr<AnalyzerNode>> body;

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeCatch;
    }

    vector<shared_ptr<AnalyzerNode>> children() override {
        return body;
    }
};

class TryAnalyzerNode : public AnalyzerNode {
public:
    vector<shared_ptr<AnalyzerNode>> body;

    vector<shared_ptr<CatchAnalyzerNode>> catch_nodes;

    AnalyzerNodeType nodeType() override {
        return kAnalyzerNodeTypeTry;
    }

    vector<shared_ptr<AnalyzerNode>> children() override {
        vector<shared_ptr<AnalyzerNode>> c;
        c.reserve(body.size() + catch_nodes.size());
        c.insert(c.end(), body.begin(), body.end());
        c.insert(c.end(), catch_nodes.begin(), catch_nodes.end());

        return c;
    }
};

class Analyzer {
public:
    Analyzer();

    shared_ptr<AnalyzerNode> analyze(const shared_ptr<ASTNode>& form, uint64_t depth = 0,
            EvaluationPhase phase = kEvaluationPhaseLoadTime);
    shared_ptr<AnalyzerNode> initialBindingWithName(const std::string& name);

    /// Collapses the given node into a vector of top level forms
    vector<shared_ptr<AnalyzerNode>> collapseTopLevelForms(const shared_ptr<AnalyzerNode>& node);
private:

    /* Passes */
    /// Run all analyzer passes
    void runPasses(const shared_ptr<AnalyzerNode>& node, uint64_t depth = 0);

    /// Recursively updates the node's `node_depth` value, starting at `starting_depth`
    void updateDepthForNode(const shared_ptr<AnalyzerNode>& node, uint64_t starting_depth = 0);

    /// Asserts that all `eval-when` forms are at the top level
    void assertEvalWhenForCompileIsTopLevel(const shared_ptr<AnalyzerNode>& node);

    /// Recursively updates the evaluation phase of all nodes that are inside eval-when forms
    void updateEvaluationPhase(const shared_ptr<AnalyzerNode>& node, EvaluationPhase phase);

    /// Recursively walks the node tree and generates a list of closed overs for each node
    vector<string> analyzeClosedOvers(const shared_ptr<AnalyzerNode>& node);

    /* Analyzers */
    shared_ptr<AnalyzerNode> analyzeForm(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeSymbol(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeInteger(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeFloat(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeString(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeNil(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeKeyword(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeBoolean(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeList(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeIf(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeDo(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeLambda(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeMacro(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeMacroExpand(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeDef(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeMaybeInvoke(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeDefFFIFn(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeQuote(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeQuasiQuote(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeUnquote(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeEvalWhen(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeTry(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode> analyzeCatch(const shared_ptr<ASTNode>& form);
    shared_ptr<AnalyzerNode>
    maybeAnalyzeSpecialForm(const shared_ptr<string>& symbol_name, const shared_ptr<ASTNode>& form);

    typedef shared_ptr<AnalyzerNode> (Analyzer::*AnalyzerFunc)(const shared_ptr<ASTNode>&);

    /* Environment */
    void pushLocalEnv();
    void popLocalEnv();
    shared_ptr<AnalyzerNode> lookupInLocalEnv(const std::string& name);
    void storeInLocalEnv(const std::string& name, shared_ptr<AnalyzerNode> initial_value);

    /* Evaluation Phase */
    void pushEvaluationPhase(EvaluationPhase phase);
    EvaluationPhase popEvaluationPhase();
    EvaluationPhase currentEvaluationPhase();

    /* Namespaces */
    shared_ptr<Namespace> currentNamespace();
    shared_ptr<Namespace> getOrCreateNamespace(string ns);

    /// Analysis functions for special forms
    const std::unordered_map<std::string, AnalyzerFunc> specialForms{
            {"if", &Analyzer::analyzeIf},
            {"do", &Analyzer::analyzeDo},
            {"lambda", &Analyzer::analyzeLambda},
            {"defmacro", &Analyzer::analyzeMacro},
            {"def", &Analyzer::analyzeDef},
            {"def-ffi-fn*", &Analyzer::analyzeDefFFIFn},
            {"quote", &Analyzer::analyzeQuote},
            {"quasiquote", &Analyzer::analyzeQuasiQuote},
            {"unquote", &Analyzer::analyzeUnquote},
            {"eval-when", &Analyzer::analyzeEvalWhen},
            {"try", &Analyzer::analyzeTry},
            {"catch", &Analyzer::analyzeCatch}
    };

    struct AnalyzerDefinition {
      EvaluationPhase phase;
      shared_ptr<AnalyzerNode> node;
    };

    /// Holds global macros
    std::unordered_map<std::string, shared_ptr<AnalyzerNode>> global_macros_;

    /// Holds already defined globals
    std::unordered_map<std::string, AnalyzerDefinition> global_env_;
    vector<unordered_map<string, shared_ptr<AnalyzerNode>>> local_envs_;

    /// Holds namespaces and their definitions
    std::unordered_map<string, shared_ptr<Namespace>> namespaces;

    /// The namespace of the currently analyzed form
    string current_ns_;

    /// Flag to specify whether the analyzer is inside a quoted form
    bool is_quoting_;

    /// The current quasiquote state
    std::vector<bool> quasi_quote_state_;

    /// Flag to specify whether the analyzer is currently analyzing a macro expander
    bool in_macro_;

    /// Stack to hold evaluation environments
    vector<EvaluationPhase> evaluation_phases_;
};
}

#endif //ELECTRUM_ANALYZER_H
